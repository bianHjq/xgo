import{c as g}from"./crypto-js-DFuDHw7_.js";var l={},D=g&&g.__classPrivateFieldGet||function(n,t,e,s){if(e==="a"&&!s)throw new TypeError("Private accessor was defined without a getter");if(typeof t=="function"?n!==t||!s:!t.has(n))throw new TypeError("Cannot read private member from an object whose class did not declare it");return e==="m"?s:e==="a"?s.call(n):s?s.value:t.get(n)},A=g&&g.__classPrivateFieldSet||function(n,t,e,s,r){if(s==="m")throw new TypeError("Private method is not writable");if(s==="a"&&!r)throw new TypeError("Private accessor was defined without a setter");if(typeof t=="function"?n!==t||!r:!t.has(n))throw new TypeError("Cannot write private member to an object whose class did not declare it");return s==="a"?r.call(n,e):r?r.value=e:t.set(n,e),e},d;Object.defineProperty(l,"__esModule",{value:!0});l.TokenData=void 0;l.parse=C;var H=l.compile=M;l.match=L;l.pathToRegexp=R;l.stringify=G;const E="/",T=n=>n,S=/^[$_\p{ID_Start}]$/u,_=/^[$\u200c\u200d\p{ID_Continue}]$/u,x="https://git.new/pathToRegexpError",b={"{":"{","}":"}","(":"(",")":")","[":"[","]":"]","+":"+","?":"?","!":"!"};function j(n){return n.replace(/[{}()\[\]+?!:*]/g,"\\$&")}function h(n){return n.replace(/[.+*?^${}()[\]|/\\]/g,"\\$&")}function*N(n){const t=[...n];let e=0;function s(){let r="";if(S.test(t[++e]))for(r+=t[e];_.test(t[++e]);)r+=t[e];else if(t[e]==='"'){let o=e;for(;e<t.length;){if(t[++e]==='"'){e++,o=0;break}t[e]==="\\"?r+=t[++e]:r+=t[e]}if(o)throw new TypeError(`Unterminated quote at ${o}: ${x}`)}if(!r)throw new TypeError(`Missing parameter name at ${e}: ${x}`);return r}for(;e<t.length;){const r=t[e],o=b[r];if(o)yield{type:o,index:e++,value:r};else if(r==="\\")yield{type:"ESCAPED",index:e++,value:t[e++]};else if(r===":"){const a=s();yield{type:"PARAM",index:e,value:a}}else if(r==="*"){const a=s();yield{type:"WILDCARD",index:e,value:a}}else yield{type:"CHAR",index:e,value:t[e++]}}return{type:"END",index:e,value:""}}class U{constructor(t){this.tokens=t,d.set(this,void 0)}peek(){if(!D(this,d,"f")){const t=this.tokens.next();A(this,d,t.value,"f")}return D(this,d,"f")}tryConsume(t){const e=this.peek();if(e.type===t)return A(this,d,void 0,"f"),e.value}consume(t){const e=this.tryConsume(t);if(e!==void 0)return e;const{type:s,index:r}=this.peek();throw new TypeError(`Unexpected ${s} at ${r}, expected ${t}: ${x}`)}text(){let t="",e;for(;e=this.tryConsume("CHAR")||this.tryConsume("ESCAPED");)t+=e;return t}}d=new WeakMap;class v{constructor(t){this.tokens=t}}l.TokenData=v;function C(n,t={}){const{encodePath:e=T}=t,s=new U(N(n));function r(a){const i=[];for(;;){const c=s.text();c&&i.push({type:"text",value:e(c)});const u=s.tryConsume("PARAM");if(u){i.push({type:"param",name:u});continue}const y=s.tryConsume("WILDCARD");if(y){i.push({type:"wildcard",name:y});continue}if(s.tryConsume("{")){i.push({type:"group",tokens:r("}")});continue}return s.consume(a),i}}const o=r("END");return new v(o)}function M(n,t={}){const{encode:e=encodeURIComponent,delimiter:s=E}=t,r=n instanceof v?n:C(n,t),o=P(r.tokens,s,e);return function(i={}){const[c,...u]=o(i);if(u.length)throw new TypeError(`Missing parameters: ${u.join(", ")}`);return c}}function P(n,t,e){const s=n.map(r=>F(r,t,e));return r=>{const o=[""];for(const a of s){const[i,...c]=a(r);o[0]+=i,o.push(...c)}return o}}function F(n,t,e){if(n.type==="text")return()=>[n.value];if(n.type==="group"){const r=P(n.tokens,t,e);return o=>{const[a,...i]=r(o);return i.length?[""]:[a]}}const s=e||T;return n.type==="wildcard"&&e!==!1?r=>{const o=r[n.name];if(o==null)return["",n.name];if(!Array.isArray(o)||o.length===0)throw new TypeError(`Expected "${n.name}" to be a non-empty array`);return[o.map((a,i)=>{if(typeof a!="string")throw new TypeError(`Expected "${n.name}/${i}" to be a string`);return s(a)}).join(t)]}:r=>{const o=r[n.name];if(o==null)return["",n.name];if(typeof o!="string")throw new TypeError(`Expected "${n.name}" to be a string`);return[s(o)]}}function L(n,t={}){const{decode:e=decodeURIComponent,delimiter:s=E}=t,{regexp:r,keys:o}=R(n,t),a=o.map(i=>e===!1?T:i.type==="param"?e:c=>c.split(s).map(e));return function(c){const u=r.exec(c);if(!u)return!1;const y=u[0],p=Object.create(null);for(let f=1;f<u.length;f++){if(u[f]===void 0)continue;const m=o[f-1],$=a[f-1];p[m.name]=$(u[f])}return{path:y,params:p}}}function R(n,t={}){const{delimiter:e=E,end:s=!0,sensitive:r=!1,trailing:o=!0}=t,a=[],i=[],c=r?"s":"is",y=(Array.isArray(n)?n:[n]).map(m=>m instanceof v?m:C(m,t));for(const{tokens:m}of y)for(const $ of w(m,0,[])){const I=O($,e,a);i.push(I)}let p=`^(?:${i.join("|")})`;return o&&(p+=`(?:${h(e)}$)?`),p+=s?"$":`(?=${h(e)}|$)`,{regexp:new RegExp(p,c),keys:a}}function*w(n,t,e){if(t===n.length)return yield e;const s=n[t];if(s.type==="group"){const r=e.slice();for(const o of w(s.tokens,0,r))yield*w(n,t+1,o)}else e.push(s);yield*w(n,t+1,e)}function O(n,t,e){let s="",r="",o=!0;for(let a=0;a<n.length;a++){const i=n[a];if(i.type==="text"){s+=h(i.value),r=i.value,o||(o=i.value.includes(t));continue}if(i.type==="param"||i.type==="wildcard"){if(!o&&!r)throw new TypeError(`Missing text after "${i.name}": ${x}`);i.type==="param"?s+=`(${q(t,o?"":r)}+)`:s+="(.+)",e.push(i),r="",o=!1;continue}}return s}function q(n,t){const e=[n,t].filter(Boolean);return e.every(r=>r.length===1)?`[^${h(e.join(""))}]`:`(?:(?!${e.map(h).join("|")}).)`}function G(n){return n.tokens.map(function t(e,s,r){if(e.type==="text")return j(e.value);if(e.type==="group")return`{${e.tokens.map(t).join("")}}`;const a=W(e.name)&&k(r[s+1])?e.name:JSON.stringify(e.name);if(e.type==="param")return`:${a}`;if(e.type==="wildcard")return`*${a}`;throw new TypeError(`Unexpected token: ${e}`)}).join("")}function W(n){const[t,...e]=n;return S.test(t)?e.every(s=>_.test(s)):!1}function k(n){return(n==null?void 0:n.type)!=="text"?!0:!_.test(n.value[0])}export{H as c};
